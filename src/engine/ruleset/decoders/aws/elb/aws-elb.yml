---
name: decoder/aws-elb/0

metadata:
  description: Decoder for Amazon ELB logs
  references:
    - htttp.
  product.name: AWS ELB (Load Balancers)

sources:
  - decoder/queue-localfile/0

check:
  - event.original: +ef_exists

definitions:
  ELBTIMESTAMP: <@timestamp/2018-08-14T14:30:02.203151Z> #TODO: whats better, example or format?
  ELBNAME: <aws.elb.name>
  ELBSOURCE: <source.ip>:<source.port>
  # Or -
  ELBBACKEND: <aws.elb.backend.ip>:<aws.elb.backend.port>
  # Or -1 for each expression
  ELBPROCESSINGTIME: >-
    <aws.elb.request_processing_time.sec>
    <aws.elb.backend_processing_time.sec>
    <aws.elb.response_processing_time.sec>
  #  Or - for each expression
  ELBSSL: <aws.elb.ssl_cipher> <aws.elb.ssl_protocol>
  ELBCOMMON: $ELBTIMESTAMP $ELBNAME $ELBSOURCE $ELBBACKEND $ELBPROCESSINGTIME
  ELBHTTPLOG: >-
    $ELBCOMMON
    <http.response.status_code>
    <aws.elb.backend.http.response.status_code>
    <http.request.body.bytes>
    <http.response.body.bytes>
    \"<http.request.method> <~tmp.uri_orig> <http.version>\"
    <~tmp.user_agent/quoted>
    $ELBSSL
  ELBTCPLOG: >-
    $ELBCOMMON
    -
    -
    <source.bytes>
    <destination.bytes>
    \"- - -<~>\"
    \"-\"
    $ELBSSL
  ELBV2TYPE: <aws.elb.type>
  ELBV2LOGVERSION: <~/ignore/ > # ignore spaces

parse:
  logpar:
    # HTTP (Classic ELB)
    - event.original: $ELBHTTPLOG
    # TCP (Classic ELB)
    - event.original: $ELBTCPLOG
    # HTTP from Application Load Balancers (v2 Load Balancers)
    - event.original: >-
        $ELBV2TYPE
        $ELBHTTPLOG
        <aws.elb.target_group.arn>
        "<aws.elb.trace_id>"
        "<destination.domain>"
        "<aws.elb.chosen_cert.arn>"
        <aws.elb.matched_rule_priority>
        <event.start/2018-08-14T14:30:02.203151Z>
        <~tmp.actions_executed/quoted>
        "<aws.elb.redirect_url>"
        "<aws.elb.error.reason>"<?~tmp.http_v2_optional>
    # TODO: process ~tmp.http_v2_optional
    # TCP from Network Load Balancers (v2 Load Balancers)
    - event.original: >-
        $ELBV2TYPE
        $ELBV2LOGVERSION
        $ELBTIMESTAMP
        $ELBNAME
        <aws.elb.listener>
        $ELBSOURCE
        $ELBBACKEND
        <aws.elb.connection_time.ms>
        <aws.elb.tls_handshake_time.ms>
        <source.bytes>
        <destination.bytes>
        <aws.elb.incoming_tls_alert>
        <aws.elb.chosen_cert.arn>
        <aws.elb.chosen_cert.serial>
        $ELBSSL
        <aws.elb.tls_named_group>
        <destination.domain>

normalize:
  - map:
      - event.kind: event
      - event.dataset: aws
      - event.module: aws
      - cloud.provider: aws
      - service.type: aws
      - trace.id: $aws.elb.trace_id
      - aws.elb.action_executed: +s_to_array/$~tmp.actions_executed/,
      - aws.elb.target_port: "+s_to_array/$~tmp.target_port/ "
      - aws.elb.target_status_code: "+s_to_array/$~tmp.target_status_code/ "
      - event.end: $@timestamp
      - tls.cipher: $aws.elb.ssl_cipher
      # TODO: process ssl_protocol once parse is avaliable on normalize

  - check:
      - http: +ef_exists
    map:
      - aws.elb.protocol: http
      - event.category: +a_append/web

  - check:
      - http.response.status_code: +i_lt/400
    map:
      - event.outcome: success

  - check:
      - http.response.status_code: +i_ge/400
    map:
      - event.outcome: failure

  - check:
      - http: +ef_not_exists
    map:
      - aws.elb.protocol: tcp
      - event.category: +a_append/network

  #TODO: add uri and user_agent once parsers are fixed
